#code that was altered for server to run the bot

import psycopg2
from urllib.parse import urlparse
result = urlparse("DATABASE_URL")
username = result.username
password = result.password
database = result.path[1:]
hostname = result.hostname
port = result.port

conn = psycopg2.connect(
    database = database,
    user = username,
    password = password,
    host = hostname,
    port = port
)

import random
import telebot
bot = telebot.TeleBot("TOKEN", parse_mode=None)

import threading
import datetime as dt
from datetime import date
from datetime import datetime
from time import sleep

#change timezone
import pytz
tz = pytz.timezone('Singapore')

import math

@bot.message_handler(commands=['help'])
def help(message):
    bot.send_message(message.from_user.id,"Here are some commands to use the features I provide. \n\n/add: Everytime you purchase food, simply log in the food, the amount (in servings) and its expiry date (in DD/MM/YYYY). I’ll help to keep track of it and remind you to consume it before it expires! \nIf you are unsure of servings portions, visit this link: https://www.healthhub.sg/live-healthy/2044/know-your-servings-photo-guide \n\n/consume: Everytime you consume a certain type of food, tell me exactly what you consumed, the amount and I’ll remove it from the list. \n\n/list: This allows you to view a list of all the available food you have at any point in time to prevent buying duplicates. \n\n *IMPORTANT* \nPlease be consistent in entering the food names (eg. if previously /add was used to add an 'apple', when you /consume, 'apple' should be entered instead of 'apples'.")



@bot.message_handler(commands=['start'])
def start(message):
    #for reminder
    cur = conn.cursor()
    cur.execute("SELECT userID FROM users;")
    result = cur.fetchall()
    ids = []
    if result:
        for tupleid in result:
            ids = ids + [tupleid[0]]

    if message.from_user.id not in ids:
        ids.append(message.from_user.id)

        #getting today's date
        sg = datetime.now(tz)
        today = sg.date()

        cur = conn.cursor()
        values = (message.from_user.id, 1, 0, today, 0, 15)
        query = "INSERT INTO users VALUES(%s, %s, %s, %s, %s, %s);"
        cur.execute(query, values)
        conn.commit()
    else:
        cur = conn.cursor()
        cur.execute(f"UPDATE users SET household = 1 WHERE userID = {message.from_user.id};")
        conn.commit()

    reply = bot.send_message(message.from_user.id, "Hello! I’m FoodSaver, I’m here to reduce food wastage. To get started, please state the number of people in your household (eg. 1, 2, 3 etc).")
    bot.register_next_step_handler(reply, nhousehold)


    
def nhousehold(message):
    #add chatid to database
    userID = message.from_user.id

    try:
        int(message.text)
    except:
        reply = bot.send_message(message.from_user.id, "Please enter a valid number.")
        bot.register_next_step_handler(reply, nhousehold)
    else:
        household_size = int(message.text)

        if household_size <= 0 or household_size > 99:
            reply = bot.send_message(message.from_user.id, "Please enter a valid number. The accepted value should be within 1 to 99.")
            bot.register_next_step_handler(reply, nhousehold)

        else:
            cur = conn.cursor()
            cur.execute(f"UPDATE users SET household = {household_size} WHERE userID = {message.from_user.id};")
            conn.commit()

            if household_size == 1:
                bot.send_message(message.from_user.id, f"There is {message.text} person in your household. You can start logging in your food. \nType /help to get guidance on how to use the bot.")
            elif household_size > 1:
                bot.send_message(message.from_user.id, f"There are {message.text} people in your household. You can start logging in your food. \nType /help to get guidance on how to use the bot.")

                

@bot.message_handler(commands=['edit_household_members'])
def edit_household_members(message):
    id = [message.from_user.id]
    cur = conn.cursor()
    query = "SELECT household FROM users WHERE userID = %s"
    cur.execute(query, id)
    result = cur.fetchall()
    result = result[0][0]
    if result == 1:
        reply = bot.send_message(message.from_user.id, f'You currently have {result} person in your household. Please state the updated number of people in your household (eg. 1, 2, 3 etc).')
    else:
        reply = bot.send_message(message.from_user.id, f'You currently have {result} people in your household. Please state the updated number of people in your household (eg. 1, 2, 3 etc).')
    bot.register_next_step_handler(reply, update_nhousehold)

def update_nhousehold(message):
    userID = message.from_user.id

    try:
        int(message.text)
    except:
        reply = bot.send_message(message.from_user.id, "Please enter a valid number.")
        bot.register_next_step_handler(reply, nhousehold)
    else:
        household_size = int(message.text)

        if household_size <= 0 or household_size > 99:
            reply = bot.send_message(message.from_user.id, "Please enter a valid number. The accepted value should be within 1 to 99.")
            bot.register_next_step_handler(reply, nhousehold)

        else:
            cur = conn.cursor()
            cur.execute(f"UPDATE users SET household = {household_size} WHERE userID = {message.from_user.id};")
            conn.commit()
            bot.send_message(message.from_user.id, f"You have successfully updated the number of people in your household to {message.text}.")


                
@bot.message_handler(commands=['add'])
def add(message):
    reply = bot.send_message(message.from_user.id, 'Please state the food name, servings and expiry date. \nEg: bell pepper 2 19/11/2022')
    bot.register_next_step_handler(reply, add_sql)



# checking for a valid input date
def validDate(date):
    try:
        day, month, year = date.split('/')
    except ValueError:
        isValidDate = False
    else:
        isValidDate = True
        try:
            dt.datetime(int(year), int(month), int(day))
        except ValueError:
            isValidDate = False

        if len(year) != 4:
            isValidDate = False
    return isValidDate



def add_sql(message):
    cur = conn.cursor()
    terms = message.text.split(" ")

    isString = 0
    for j in range(len(terms) - 2):
        if terms[j].isalpha():
            isString += 1
            
    if message.text == "/cancel":
        bot.send_message(message.from_user.id, "You exited /add command.")
    elif len(terms) >= 3 and isString == len(terms) - 2 and terms[-2].isdigit() and validDate(terms[-1]):
        userID = message.from_user.id
        food_name = ""
        for i in range(len(terms) - 2):
            food_name += (terms[i]).lower() #convert all to lower case
            if i != len(terms) - 3:
                food_name += " "
        servings = int(terms[-2])
        expiry_date = terms[-1]
        expiry_date = dt.datetime.strptime(expiry_date, "%d/%m/%Y").date()

        #getting today's date
        sg = datetime.now(tz)
        today = sg.date()
        if (expiry_date - today).days < 0: #expiry date earlier than today
            reply = bot.send_message(message.from_user.id, 'Invalid date! Date cannot be earlier than today. Please try again!')
            bot.register_next_step_handler(reply, add_sql)

        elif servings <= 0 or servings > 999:
            reply = bot.send_message(message.from_user.id, 'Invalid serving value! Value should be within 1-999. Please try again!')
            bot.register_next_step_handler(reply, add_sql)
        
        else:
            #check if the same food (with same expiry date already exists in database)
            cur = conn.cursor()
            checking_query = "SELECT foodID, foodName, servings, expiryDate FROM food WHERE food.foodName = %s AND food.expiryDate = %s AND userID = %s"
            checking_values = (food_name, expiry_date, message.from_user.id)
            cur.execute(checking_query, checking_values)
            data = cur.fetchall()

            if len(data) == 0:
                foodID = random.randint(1000, 9999)
                cur = conn.cursor()
                cur.execute('SELECT foodID FROM food')
                result = cur.fetchall()
                while foodID in result:
                    foodID =  random.randint(1000, 9999)
                # INSERT SQL code to add this into our database
                values = (foodID, food_name, servings, expiry_date, userID)
                cur = conn.cursor()
                add_query = "INSERT INTO food VALUES(%s, %s, %s, %s, %s);"
                cur.execute(add_query, values)
                conn.commit()

            else:
                existing_foodID = data[0][0]
                #existing record of food with same expiry date, just add
                total_servings = int(data[0][2]) + int(servings)
                cur = conn.cursor()
                add = f"UPDATE food SET servings = {total_servings} WHERE foodID = {existing_foodID}"
                cur.execute(add)
                conn.commit()

            reply = "This is added to your food stock: \n"
            if servings == "1":
                expiry_date = expiry_date.strftime('%d/%m/%Y')
                reply += f"{food_name} ({servings} serving) expires {expiry_date} \n"
            else:
                expiry_date = expiry_date.strftime('%d/%m/%Y')
                reply += f"{food_name} ({servings} servings) expires {expiry_date} \n"
            bot.send_message(message.from_user.id, reply)
            conn.commit()
    else:
        reply = bot.send_message(message.from_user.id, 'Invalid input! Please follow the specified format. Eg: "Apple 2 15/10/2022"')
        bot.register_next_step_handler(reply, add_sql)



@bot.message_handler(commands=['list'])
def list(message):
    values = [message.from_user.id]
    cur = conn.cursor()
    #query = "SELECT foodID, foodName, servings, expiryDate FROM food WHERE userID = %s"
    query = "SELECT foodID, foodName, servings, expiryDate FROM food WHERE userID = %s ORDER BY expiryDate, foodName"
    cur.execute(query, values)
    cursor = cur.fetchall()
    reply = "This is the current food stock you have: \n"
    for row in cursor:
      food_name = row[1]
      servings = row[2]
      expiry_date = row[3]
      expiry_date = expiry_date.strftime('%d/%m/%Y')
      if servings == "1":
        reply += f"{food_name} ({servings} serving) expires {expiry_date} \n"
      else:
        reply += f"{food_name} ({servings} servings) expires {expiry_date} \n"
    bot.send_message(message.from_user.id, reply)



@bot.message_handler(commands=['consume'])
def consume(message):
    data = [message.from_user.id]
    cur = conn.cursor()
    query = "SELECT * FROM food WHERE userID = %s"
    cur.execute(query, data)
    result = cur.fetchall()
    
    #user doesnt have anything in their list
    if len(result) == 0:
        reply = bot.send_message(message.from_user.id, 'Sorry, you do not have any food in your list. Use /add to add some food before comsuming them!')
    else:
        reply = bot.send_message(message.from_user.id, 'Please state the food name and servings consumed. \nEg: bell pepper 1')
        bot.register_next_step_handler(reply, consume_sql)



def consume_sql(message):
    terms = message.text.split(" ")
    userID = message.from_user.id

    isString = 0
    for j in range(len(terms) - 1):
        if terms[j].isalpha():
            isString += 1
            
    if message.text == "/cancel":
        bot.send_message(message.from_user.id, "You exited /consume command.")
    elif len(terms) >= 2 and isString == len(terms) - 1 and terms[-1].isdigit():
        food_name = ""
        for i in range(len(terms) - 1):
            food_name += (terms[i]).lower() #convert all to lower case
            if i != len(terms) - 2:
                food_name += " "
        servings_consumed = int(terms[-1])

        ###update Food SQL
        values = [food_name, userID]
        cur = conn.cursor()
        query = "SELECT foodID, servings FROM food WHERE foodName = %s AND userID = %s ORDER BY expiryDate"
        cur.execute(query, values)
        food = cur.fetchall()

        if len(food) == 0: # the input food by user isnt in the foodstock
            servings_consumed = 0 #set this to zero so it wouldnt add this serving to weekly serving consumption
            reply = bot.send_message(message.from_user.id, 'Invalid input! You do not have this in your food stock. Please try again!')
            bot.register_next_step_handler(reply, consume_sql)
   
        elif servings_consumed <= 0:
            servings_consumed = 0 #set this to zero so it wouldnt add this serving to weekly serving consumption
            reply = bot.send_message(message.from_user.id, 'Invalid serving value! Value should at least be 1. Please try again!')
            bot.register_next_step_handler(reply, consume_sql)
            
        else:
            if len(food) == 1:
                #theres only 1 food with that name, juz update the servings of the only row
                earliest_foodID = food[0][0]
                servings_available = food[0][1]
                
                if servings_consumed > servings_available:
                    servings_consumed = 0 #set this to zero so it wouldnt add this serving to weekly serving consumption
                    reply = bot.send_message(message.from_user.id, 'Your serving input is more than what you have in your food stock! Please try again with the correct number of servings.')
                    bot.register_next_step_handler(reply, consume_sql)
                elif servings_consumed == servings_available:
                    #delete from database
                    cur = conn.cursor()
                    cur.execute(f"DELETE FROM food WHERE foodID = {earliest_foodID} AND userID = {message.from_user.id}")
                    conn.commit()
                    
                    reply = f"This is removed from your food list: \n {food_name} ({servings_consumed} serving(s))\n"
                    bot.send_message(message.from_user.id, reply)
                else:
                    #update database
                    servings_left = servings_available - servings_consumed
                    cur = conn.cursor()
                    cur.execute(f"UPDATE food SET servings = {servings_left} WHERE foodID = {earliest_foodID} AND userID = {message.from_user.id}")
                    conn.commit()     
                    
                    reply = f"This is removed from your food list: \n {food_name} ({servings_consumed} serving(s))\n"
                    bot.send_message(message.from_user.id, reply)
            else:
                #sum all servings with diff expiry dates, then start deducting servings from earliest expiry
                servings_sum = 0
                for foodrow in food:
                    servings_sum += foodrow[1]
                    
                if servings_consumed > servings_sum:
                    servings_consumed = 0 #set this to zero so it wouldnt add this serving to weekly serving consumption
                    reply = bot.send_message(message.from_user.id, 'Your serving input is more than what you have in your food stock! Please try again with the correct number of servings.')
                    bot.register_next_step_handler(reply, consume_sql)
                elif servings_consumed == servings_sum:
                    #all the food across diff expiry dates are consumed 
                    for foodrow in food:
                        foodid_to_delete = foodrow[0]
                        cur = conn.cursor()
                        cur.execute(f"DELETE FROM food WHERE foodID = {foodid_to_delete} AND userID = {message.from_user.id}")
                        conn.commit()
                    
                    reply = f"This is removed from your food list: \n {food_name} ({servings_consumed} serving(s))\n"
                    bot.send_message(message.from_user.id, reply)                        
                else:
                    #check which rows need to deleted/updated based on how many servings are consumed (according to order of expiry)
                    servings_consumed_counter = servings_consumed #use counter as servings_consumed is required later on
                    for foodrow in food:
                        if servings_consumed_counter - foodrow[1] >= 0:
                            #delete this row 
                            foodid_to_delete = foodrow[0]
                            cur = conn.cursor()
                            cur.execute(f"DELETE FROM food WHERE foodID = {foodid_to_delete} AND userID = {message.from_user.id}")
                            conn.commit()
                        elif servings_consumed_counter > 0:
                            #update this row
                            foodid_to_update = foodrow[0]
                            cur = conn.cursor()
                            update_serving_value = foodrow[1] - servings_consumed_counter
                            cur.execute(f"UPDATE food SET servings = {update_serving_value} WHERE foodID = {foodid_to_update} AND userID = {message.from_user.id}")
                            conn.commit()
                        
                        servings_consumed_counter = servings_consumed_counter - foodrow[1]
                    
                    reply = f"This is removed from your food list: \n {food_name} ({servings_consumed} serving(s))\n"
                    bot.send_message(message.from_user.id, reply)                        

        ###update User SQL (servings consumed for the week)
        cur = conn.cursor()
        cur.execute(f"SELECT weeklyServings FROM users WHERE userID = {message.from_user.id}")
        result = cur.fetchall()
        updated_servings = int(result[0][0]) + int(servings_consumed)

        cur = conn.cursor()
        cur.execute(f"UPDATE users SET weeklyServings = {updated_servings} WHERE userID = {message.from_user.id};")
        conn.commit()
     
    else:
        reply = bot.send_message(message.from_user.id, 'Invalid input! Please follow the specified format. Eg: "Apple 2"')
        bot.register_next_step_handler(reply, consume_sql)
        
        
        
#edit command
from telebot import types

markup = types.ReplyKeyboardMarkup(row_width=1, one_time_keyboard=True)
food_name = types.KeyboardButton('Food Name')
servings = types.KeyboardButton('Servings')
expiry = types.KeyboardButton('Expiry Date')
markup.add(food_name, servings, expiry)

id_and_food_dict = {}

@bot.message_handler(commands=['edit'])
def edit(message):
    data = [message.from_user.id]
    cur = conn.cursor()
    query = "SELECT * FROM food WHERE userID = %s"
    cur.execute(query, data)
    result = cur.fetchall()
    
    #user doesnt have anything in their list
    if len(result) == 0:
        reply = bot.send_message(message.from_user.id, 'Sorry, you do not have any food in your list. Use /add to add some food before editing them!')
    else:
        reply = bot.send_message(message.from_user.id, "Please input the food that you want to edit.")
        bot.register_next_step_handler(reply, choose_food)
        
    
    
def choose_food(message):
    foodname = message.text.lower()
    userID = message.from_user.id
    
    values = [foodname, userID]
    cur = conn.cursor()
    query = "SELECT foodName, servings, expiryDate FROM food WHERE foodName = %s AND userID = %s ORDER BY expiryDate"
    cur.execute(query, values)
    foodlist = cur.fetchall() #list can have 1 or more items (if theres 2 apple with diff expiry dates then there will be 2 entries)
    
    global id_and_food_dict

    if message.text == "/cancel":
        bot.send_message(message.from_user.id, "You exited /edit command.")
        
    elif len(foodlist) == 0: #no such food inside
        reply = bot.send_message(message.from_user.id, "Invalid input! You do not have this in your food stock. Please try again!")
        bot.register_next_step_handler(reply, choose_food)
        
    elif len(foodlist) == 1: #theres exactly 1 food with this name
        name = foodlist[0][0]
        serving = foodlist[0][1]
        expiry = foodlist[0][2]
        expiry = expiry.strftime('%d/%m/%Y')
        
        id_and_food_dict[userID] = foodlist
        
        reply = bot.send_message(message.from_user.id, f"Here is what you currently have:\n{name} ({serving} serving(s)) expiring on {expiry}\nSelect the category you want to edit:", reply_markup=markup)
        bot.register_next_step_handler(reply, edit_sql)
    
    else:
        text = ""
        for i in range(len(foodlist)):
            name = foodlist[i][0]
            serving = foodlist[i][1]
            expiry = foodlist[i][2]
            expiry = expiry.strftime('%d/%m/%Y')
            text += str(i + 1) + " -- " + name + " (" + str(serving) + " serving(s)) expiring on " + expiry + "\n"

        id_and_food_dict[userID] = foodlist
        
        reply = bot.send_message(message.from_user.id, f"Here is what you currently have:\n{text}\nSelect the option you want to edit.")
        bot.register_next_step_handler(reply, choose_option)
        
def choose_option(message):
    foodoption = message.text
    userID = message.from_user.id
    
    global id_and_food_dict
    original_foodlist = id_and_food_dict[userID]
    
    if message.text == "/cancel":
        bot.send_message(message.from_user.id, "You exited /edit command.")
    else:    
        try:
            int(foodoption)
        except:
            reply = bot.send_message(message.from_user.id, "Invalid option! Please select one of the options offered above.")
            bot.register_next_step_handler(reply, choose_option)
        else:
            if int(foodoption) > len(original_foodlist) or int(foodoption) <= 0: #invalid option input (more or less than what was offered)
                reply = bot.send_message(message.from_user.id, f"Invalid option! Please select one of the options offered above.")
                bot.register_next_step_handler(reply, choose_option)

            else:
                new_foodlist = original_foodlist[int(foodoption) - 1]
                id_and_food_dict[userID] = [new_foodlist]

                reply = bot.send_message(message.from_user.id, f"Select the category you want to edit:", reply_markup=markup)
                bot.register_next_step_handler(reply, edit_sql)


                
def edit_sql(message: types.Message):
    if message.text == "/cancel":
        bot.send_message(message.from_user.id, "You exited /edit command.")
    elif message.text == "Food Name":
        reply = bot.send_message(message.from_user.id, "Please input the new food name.")
        bot.register_next_step_handler(reply, edit_food_name_sql)               
    elif message.text == "Servings":
        reply = bot.send_message(message.from_user.id, "Please input the new number of servings.")
        bot.register_next_step_handler(reply, edit_servings_sql)      
    elif message.text == "Expiry Date":
        reply = bot.send_message(message.from_user.id, "Please input the new expiry date (in the form of DD/MM/YYYY).")
        bot.register_next_step_handler(reply, edit_expiry_sql)
    else:
        reply = bot.send_message(message.from_user.id, "Please select one of the buttons.")
        bot.register_next_step_handler(reply, edit_sql)     
        
        
def edit_food_name_sql(message): 
    userID = message.from_user.id
    terms = message.text.split(" ")
    
    isString = 0
    for i in range(len(terms)):
        if terms[i].isalpha():
            isString += 1
    
    if message.text == "/cancel":
        bot.send_message(message.from_user.id, "You exited /edit command.")
    elif isString != len(terms): #input name isnt all alphabets
        reply = bot.send_message(message.from_user.id, 'Invalid input! Please make sure that the new name contains alphabets only.')
        bot.register_next_step_handler(reply, edit_food_name_sql)
    else:
        new_name = ""
        for i in range(len(terms)):
            new_name += (terms[i]).lower() #convert all to lower case
            if i != len(terms) - 1:
                new_name += " "
                
        global id_and_food_dict
        foodlist = id_and_food_dict[userID]
        foodlist = foodlist[0] #getting tuple out of list
        old_name = foodlist[0]
        servings = int(foodlist[1])
        expiry = foodlist[2]
        
        #check if there is an entry of the new name and the same expiry date. if there is then add the 2 servings up and update it and delete row with old name
        cur = conn.cursor()
        values = (new_name, expiry.strftime('%Y-%m-%d'), message.from_user.id)
        cur.execute("SELECT foodID, servings FROM food WHERE foodName = %s AND expiryDate = %s AND userID = %s", values)
        cursor = cur.fetchall()
        if len(cursor) > 0: #theres an existing entry
            newname_foodID = cursor[0][0]
            newname_old_servings = cursor[0][1]
            newname_new_servings = newname_old_servings + servings
            
            #update the added up servings
            cur = conn.cursor()
            updated_values = (newname_new_servings, newname_foodID, message.from_user.id)
            cur.execute(f"UPDATE food SET servings = %s WHERE foodID = %s AND userID = %s", updated_values) 
            conn.commit() 
            
            #get id of old name then delete that row
            cur = conn.cursor()
            values = (old_name, servings, expiry.strftime('%Y-%m-%d'), message.from_user.id)
            cur.execute("SELECT foodID FROM food WHERE foodName = %s AND servings = %s AND expiryDate = %s AND userID = %s", values)
            cursor = cur.fetchall()
            oldname_foodID = cursor[0][0]
            
            cur = conn.cursor()
            values = (oldname_foodID, message.from_user.id)
            cur.execute(f"DELETE FROM food WHERE foodID = %s AND userID = %s", values)
            conn.commit() 

        else: #new name doesnt exist yet, simply update food name
            cur = conn.cursor()
            values = (old_name, servings, expiry.strftime('%Y-%m-%d'), message.from_user.id)
            cur.execute("SELECT foodID FROM food WHERE foodName = %s AND servings = %s AND expiryDate = %s AND userID = %s", values)
            cursor = cur.fetchall()
            foodID = cursor[0][0]
            
            #update food name
            cur = conn.cursor()
            updated_values = (new_name, foodID, message.from_user.id)
            cur.execute(f"UPDATE food SET foodName = %s WHERE foodID = %s AND userID = %s", updated_values)
            conn.commit() 

        #delete from dict
        del id_and_food_dict[message.from_user.id]
        
        bot.send_message(message.from_user.id, f"Food name successfully updated from {old_name} to {new_name}.")

   
    
def edit_servings_sql(message):
    userID = message.from_user.id
    
    if message.text == "/cancel":
        bot.send_message(message.from_user.id, "You exited /edit command.")
    else:
        try:
            int(message.text)
        except:
            reply = bot.send_message(message.from_user.id, "Please enter a valid number.")
            bot.register_next_step_handler(reply, edit_servings_sql)
        else:
            new_servings = int(message.text)

            if new_servings < 0 or new_servings > 999:
                reply = bot.send_message(message.from_user.id, "Please enter a valid number. The accepted value should be within 0 to 999.")
                bot.register_next_step_handler(reply, edit_servings_sql)

            else:
                global id_and_food_dict
                foodlist = id_and_food_dict[userID]
                foodlist = foodlist[0] #getting tuple out of list
                name = foodlist[0]
                old_servings = int(foodlist[1])
                expiry = foodlist[2]

                cur = conn.cursor()
                values = (name, old_servings, expiry.strftime('%Y-%m-%d'), message.from_user.id)
                cur.execute("SELECT foodID FROM food WHERE foodName = %s AND servings = %s AND expiryDate = %s AND userID = %s", values)
                cursor = cur.fetchall()
                foodID = cursor[0][0]

                #delete from dict
                del id_and_food_dict[message.from_user.id]

                #update
                if int(new_servings) != 0:
                    cur = conn.cursor()
                    updated_values = (new_servings, foodID, message.from_user.id)
                    cur.execute(f"UPDATE food SET servings = %s WHERE foodID = %s AND userID = %s", updated_values)
                    conn.commit()
                    bot.send_message(message.from_user.id, f"Number of servings of {name} successfully updated from {old_servings} to {new_servings}.")
                else:
                    cur = conn.cursor()
                    data = (foodID, message.from_user.id)
                    cur.execute(f"DELETE FROM food WHERE foodID = %s AND userID = %s", data)
                    conn.commit()
                    bot.send_message(message.from_user.id, f"{old_servings} serving(s) of {name} is removed from your list.")  

    
 
def edit_expiry_sql(message):
    userID = message.from_user.id
    expiry_date = message.text
    
    if message.text == "/cancel":
        bot.send_message(message.from_user.id, "You exited /edit command.")
    else:
        try:
            dt.datetime.strptime(expiry_date, "%d/%m/%Y").date()
        except:
            #input isnt a date form (can be str, int etc)
            reply = bot.send_message(message.from_user.id, "Please enter a valid expiry date.")
            bot.register_next_step_handler(reply, edit_expiry_sql)
        else:
            #getting today's date
            sg = datetime.now(tz)
            today = sg.date()
            if not validDate(expiry_date):
                #date isnt a valid date
                reply = bot.send_message(message.from_user.id, "Please enter a valid expiry date.")
                bot.register_next_step_handler(reply, edit_expiry_sql)
            elif (dt.datetime.strptime(expiry_date, "%d/%m/%Y").date() - today).days < 0: #expiry date earlier than today
                reply = bot.send_message(message.from_user.id, 'Invalid date! Date cannot be earlier than today. Please try again!')
                bot.register_next_step_handler(reply, edit_expiry_sql)
            else:
                global id_and_food_dict
                foodlist = id_and_food_dict[userID]
                foodlist = foodlist[0] #getting tuple out of list
                name = foodlist[0]
                servings = int(foodlist[1])
                old_expiry = foodlist[2]
                new_expiry = dt.datetime.strptime(expiry_date, "%d/%m/%Y").date()

                #delete from dict
                del id_and_food_dict[message.from_user.id]

                ## CHECKING FOR NAME WITH SAME NEW EXPIRY
                #check if there is an entry of the same name and the new expiry date. if there is then add the 2 servings up and update it and delete row with old expiry
                cur = conn.cursor()
                values = (name, new_expiry.strftime('%Y-%m-%d'), message.from_user.id)
                cur.execute("SELECT foodID, servings FROM food WHERE foodName = %s AND expiryDate = %s AND userID = %s", values)
                cursor = cur.fetchall()
                if len(cursor) > 0: #theres an existing entry
                    newexpiry_foodID = cursor[0][0]
                    newexpiry_old_servings = cursor[0][1]
                    newexpiry_new_servings = newexpiry_old_servings + servings

                    #update the added up servings
                    cur = conn.cursor()
                    updated_values = (newexpiry_new_servings, newexpiry_foodID, message.from_user.id)
                    cur.execute(f"UPDATE food SET servings = %s WHERE foodID = %s AND userID = %s", updated_values) 
                    conn.commit() 

                    #get id of old expiry then delete that row
                    cur = conn.cursor()
                    values = (name, servings, old_expiry.strftime('%Y-%m-%d'), message.from_user.id)
                    cur.execute("SELECT foodID FROM food WHERE foodName = %s AND servings = %s AND expiryDate = %s AND userID = %s", values)
                    cursor = cur.fetchall()
                    oldexpiry_foodID = cursor[0][0]

                    cur = conn.cursor()
                    values = (oldexpiry_foodID, message.from_user.id)
                    cur.execute(f"DELETE FROM food WHERE foodID = %s AND userID = %s", values)
                    conn.commit() 

                else: #new expiry doesnt exist yet, simply update expiry
                    cur = conn.cursor()
                    values = (name, servings, old_expiry.strftime('%Y-%m-%d'), message.from_user.id)
                    cur.execute("SELECT foodID FROM food WHERE foodName = %s AND servings = %s AND expiryDate = %s AND userID = %s", values)
                    cursor = cur.fetchall()
                    foodID = cursor[0][0]
                    #update
                    cur = conn.cursor()
                    updated_values = (new_expiry.strftime('%Y-%m-%d'), foodID, message.from_user.id)
                    cur.execute(f"UPDATE food SET expiryDate= %s WHERE foodID = %s AND userID = %s", updated_values)
                    conn.commit() 
                bot.send_message(message.from_user.id, f"Expiry date of {name} successfully updated from {old_expiry.strftime('%d/%m/%Y')} to {new_expiry.strftime('%d/%m/%Y')}")


    
@bot.message_handler(commands=['cancel'])
def cancel(message):
    bot.send_message(message.from_user.id,"You are currently in the main menu and have no operation to cancel. \nPlease only use /cancel when you want to exit the /add, /consume or /edit operation.")

    
    
@bot.message_handler(func=lambda message: True)
def unknown(message):
    reply = message.text
    bot.reply_to(message, "Sorry, there is no such command. \nReply /help if you need guidance on how to use this bot.")


    
def cus_send_message(id, text):
     try:
        bot.send_message(id, text)
     except Exception as e:
        print(e)

def threading_func():
    cur = conn.cursor()
    cur.execute("SELECT userID FROM users;")
    result = cur.fetchall()
    ids = []
    if result:
        for tupleid in result:
            ids = ids + [tupleid[0]]

    while True:
        for id in ids:
            ##### send reminder for soon to be expired food #####
            data = [id]
            cur = conn.cursor()
            expiry_query = "SELECT * FROM food WHERE userID = %s ORDER BY foodName"
            cur.execute(expiry_query, data)
            result = cur.fetchall()
            conn.commit()
            
            #getting today's date
            sg = datetime.now(tz)
            today = sg.date()
            
            expiring_today = 0
            expiring_oneday = 0
            expiring_threedays = 0
            expiring_today_food = ""
            expiring_oneday_food = ""
            expiring_threedays_food = ""

            for i in result:
                expiry_date = i[3] 
                food_name = i[1]
                days_diff = (expiry_date - today).days
                if days_diff == 0:
                    if expiring_today > 0:
                        expiring_today_food += ", "
                    expiring_today_food += food_name
                    expiring_today += 1
                elif days_diff == 1:
                    if expiring_oneday > 0:
                        expiring_oneday_food += ", "
                    expiring_oneday_food += food_name
                    expiring_oneday += 1
                elif days_diff == 3:
                    if expiring_threedays > 0:
                        expiring_threedays_food += ", "
                    expiring_threedays_food += food_name
                    expiring_threedays += 1
                    
            reply = "You have food expiring soon!\n"
            if expiring_today != 0:
                reply += "Expiring today: " + expiring_today_food + "\n"
            if expiring_oneday != 0:
                reply += "Expiring in 1 day: " + expiring_oneday_food + "\n"
            if expiring_threedays != 0:
                reply += "Expiring in 3 days: " + expiring_threedays_food + "\n"
            reply += "Consume them soon, don’t let them go to waste!"
            
            if expiring_today + expiring_oneday + expiring_threedays != 0:
                cus_send_message(id, reply)



            ##### send purchase limit message #####
            servings_div_by_days_left = 0
            data = [id]
            cur = conn.cursor()
            food_query = "SELECT * fROM Food WHERE userID = %s"
            cur.execute(food_query, data)
            result = cur.fetchall()
            #cur.close()

            #getting today's date
            sg = datetime.now(tz)
            today = sg.date()

            for i in result:
                expiry_date = dt.datetime.strptime(str(i[3]), "%Y-%m-%d").date()
                days_left = (expiry_date - today).days
                num_servings = int(i[2])

                #if the food expires today, then change it to 1 (1 day left to eat)
                if days_left == 0:
                    days_left = 1
                servings_div_by_days_left += num_servings / days_left

            cur = conn.cursor()
            hh_member_query = "SELECT household FROM users WHERE userID = %s"
            cur.execute(hh_member_query, data)
            num_hh_members_result = cur.fetchall()
            #cur.close()

            cur = conn.cursor()
            user_serving_lim_query = "SELECT servingLimit FROM users WHERE userID = %s"
            cur.execute(user_serving_lim_query, data)
            user_serving_lim_result = cur.fetchall()
            #cur.close()

            if servings_div_by_days_left / int(num_hh_members_result[0][0]) > int(user_serving_lim_result[0][0]):
                cus_send_message(id, "Oops! It seems that you might have bought too much food to be consumed by your household before they expire! Do think twice before buying more food!")



            ##### update weekly consumption #####
            data = [id]

            #getting today's date
            sg = datetime.now(tz)
            today = sg.date()

            cur = conn.cursor()
            reset_date_query = "SELECT startDate FROM users WHERE userID = %s"
            cur.execute(reset_date_query, data)
            result = cur.fetchall()
            stored_date = result[0][0] #dt.datetime.strptime(result[0][0], "%Y-%m-%d").date()
            
            if (today - stored_date).days % 7 == 0 and (today - stored_date).days != 0: #7 days interval since it is a weekly update and not == start date
                cur = conn.cursor()
                weekly_servings_consumed_query = "SELECT weeklyServings FROM users WHERE userID = %s"
                cur.execute(weekly_servings_consumed_query, data)
                weekly_servings_consumed_result = cur.fetchall()
                weekly_servings_consumed = int(weekly_servings_consumed_result[0][0])

                cur = conn.cursor()
                hh_member_query = "SELECT household FROM users WHERE userID = %s"
                cur.execute(hh_member_query, data)
                num_hh_members_result = cur.fetchall()
                num_hh_members = int(num_hh_members_result[0][0])

                user_limit = weekly_servings_consumed / num_hh_members / 7
                rounded_value = math.ceil(user_limit)
                
                #update new limit for this user
                if rounded_value > 0:
                    cur = conn.cursor()
                    cur.execute(f"UPDATE users SET servingLimit = {rounded_value} WHERE userID = {id};")
                    conn.commit()

                #make serving count to be back to 0
                cur = conn.cursor()
                cur.execute(f"UPDATE users SET weeklyServings = 0 WHERE userID = {id};")
                conn.commit()
       
       
       
            ##### checking for expired food #####
            curr_id = [id]

            #getting today's date
            sg = datetime.now(tz)
            today = sg.date()

            cur = conn.cursor()
            query = "SELECT foodID, foodName, servings, expiryDate FROM food WHERE userID = %s"
            cur.execute(query, curr_id)
            cursor = cur.fetchall()

            for row in cursor:
                food_id = row[0]
                food_name = row[1]
                servings = row[2]
                expiry_date = row[3]
                if (expiry_date - today).days < 0: #food expired
                    expiry_date = expiry_date.strftime('%d/%m/%Y')
                    cus_send_message(id, f"Oh no! It seems like you forgot to consume {servings} serving(s) of {food_name} which expired on {expiry_date}. It has been removed from your food stock.")
                    cur.execute(f"DELETE FROM food WHERE foodID = {food_id}")
                    conn.commit()

        sleep(9000)
worker = threading.Thread(target=threading_func, args=())
worker.start()


bot.infinity_polling(timeout=10, long_polling_timeout = 5)
#bot.polling(none_stop=True, interval=0)
